sudo tee /usr/local/bin/uriosp >/dev/null <<'SH'
#!/usr/bin/env bash
set -euo pipefail

APP="uriosp"

ETC="/etc/uriosp"
PROFILES="$ETC/profile"
ACTIVE="$ETC/active"

LOGDIR="/var/log/uriosp-logs"
LOGFILE="$LOGDIR/uriosp.log"

GROUP="uriosp"
DEFAULT_CLOUD="${URIOSP_DEFAULT_CLOUD:-openstack}"
STRICT_CLOUD="${URIOSP_STRICT_CLOUD:-1}"  # 1=block if YAML missing DEFAULT_CLOUD, 0=warn
SESSION_PASS_ENV="URIOSP_OS_PASSWORD"

# readonly guard for `uriosp os` (hard readonly)
ALLOW_WRITE="0"

die(){ echo "ERROR: $*" >&2; exit 1; }
need(){ command -v "$1" >/dev/null 2>&1 || die "Missing: $1"; }

log(){
  local level="$1"; shift
  { echo "$(date -Is) level=$level user=${SUDO_USER:-$USER} msg=$*"; } >> "$LOGFILE" 2>/dev/null || true
}

ensure_layout_root(){
  [[ $EUID -eq 0 ]] || die "This action requires root. Use sudo."
  groupadd -f "$GROUP"
  mkdir -p "$ETC" "$PROFILES" "$LOGDIR"
  touch "$ACTIVE" "$LOGFILE"
  chown -R root:"$GROUP" "$ETC" "$LOGDIR"
  chmod 0750 "$ETC" "$PROFILES"
  chmod 0770 "$LOGDIR"
  chmod 0640 "$ACTIVE"
  chmod 0660 "$LOGFILE"
}

cfg_path(){ echo "$PROFILES/$1.yaml"; }

has_default_cloud(){
  local cfg="$1" cloud="$2"
  awk -v want="$cloud" '
    /^clouds:[[:space:]]*$/ {inside=1; next}
    inside && /^[[:space:]]+[A-Za-z0-9_.-]+:[[:space:]]*$/ {
      key=$1; sub(/:$/, "", key);
      if (key == want) { found=1; exit }
    }
    END { exit(found?0:1) }
  ' "$cfg"
}

get_active(){
  [[ -r "$ACTIVE" ]] || die "No active profile. Run: sudo $APP config <clouds.yaml>"
  local p; p="$(tr -d '[:space:]' < "$ACTIVE")"
  [[ -n "$p" ]] || die "Active profile empty. Re-run config."
  echo "$p"
}

require_session_password(){
  local val="${!SESSION_PASS_ENV-}"
  [[ -n "$val" ]] || die "No session password loaded. Run: eval \"\$($APP auth)\""
}

run_openstack(){
  need openstack
  local profile cfg
  profile="$(get_active)"
  cfg="$(cfg_path "$profile")"
  [[ -r "$cfg" ]] || die "Profile not readable: $cfg (add your user to group '$GROUP')"

  if ! has_default_cloud "$cfg" "$DEFAULT_CLOUD"; then
    log "WARN" "RUN profile=$profile note=missing_default_cloud cfg=$cfg"
    if [[ "$STRICT_CLOUD" == "1" ]]; then
      die "Active profile YAML missing clouds: $DEFAULT_CLOUD:. Refusing to run."
    else
      echo "WARNING: Active profile YAML missing clouds: $DEFAULT_CLOUD:. This will likely fail." >&2
    fi
  fi

  require_session_password

  OS_CLIENT_CONFIG_FILE="$cfg" \
  OS_CLOUD="$DEFAULT_CLOUD" \
  OS_PASSWORD="${!SESSION_PASS_ENV}" \
  openstack "$@"
}

cmd_auth(){
  local pw
  read -r -s -p "OpenStack Password (session-only): " pw
  echo >&2
  [[ -n "$pw" ]] || die "Empty password."
  printf 'export %s=%q\n' "$SESSION_PASS_ENV" "$pw"
  log "INFO" "AUTH loaded session password (not persisted)"
}

cmd_config(){
  local src="${1:-}"
  [[ -n "$src" ]] || die "Usage: $APP config <clouds.yaml>"
  [[ -f "$src" ]] || die "File not found: $src"

  ensure_layout_root

  local base profile dst
  base="$(basename "$src")"
  profile="${base%.*}"
  dst="$(cfg_path "$profile")"

  cp -f "$src" "$dst"
  chown root:"$GROUP" "$dst"
  chmod 0640 "$dst"

  if ! has_default_cloud "$dst" "$DEFAULT_CLOUD"; then
    log "WARN" "CONFIG profile=$profile note=missing_default_cloud file=$dst"
    if [[ "$STRICT_CLOUD" == "1" ]]; then
      die "YAML does not contain clouds: $DEFAULT_CLOUD:. Fix the file or set URIOSP_DEFAULT_CLOUD."
    else
      echo "WARNING: YAML missing clouds: $DEFAULT_CLOUD:. '$APP os' may fail." >&2
    fi
  fi

  echo "$profile" > "$ACTIVE"
  chown root:"$GROUP" "$ACTIVE"
  chmod 0640 "$ACTIVE"

  log "INFO" "CONFIG ok profile=$profile dst=$dst"
  echo "OK: stored profile '$profile' -> $dst"
  echo "Active profile: $profile"
  echo "Default cloud: $DEFAULT_CLOUD"
}

cmd_use(){
  local profile="${1:-}"
  [[ -n "$profile" ]] || die "Usage: $APP use <profile>"
  [[ -r "$(cfg_path "$profile")" ]] || die "Profile not found or not readable: $(cfg_path "$profile")"
  echo "$profile" | sudo tee "$ACTIVE" >/dev/null
  log "INFO" "USE profile=$profile"
  echo "Active profile: $profile"
}

cmd_list_profiles(){
  [[ -d "$PROFILES" ]] || { echo "(no profiles)"; exit 0; }
  ls -1 "$PROFILES" 2>/dev/null | sed -n 's/\.yaml$//p' || true
}

is_dangerous_os() {
  local tok low
  for tok in "$@"; do
    low="$(printf '%s' "$tok" | tr '[:upper:]' '[:lower:]')"
    case "$low" in
      create|delete|purge|set|unset|add|remove|rename|update|patch|replace|retype|extend|shrink|\
      rebuild|resize|migrate|evacuate|reboot|stop|start|pause|unpause|suspend|resume|lock|unlock|\
      attach|detach|associate|disassociate|bind|unbind|grant|revoke|approve|reject|promote|demote|\
      enable|disable|failover|recover|reset|clear)
        return 0 ;;
    esac
  done
  return 1
}

cmd_os(){
  # hard readonly
  if is_dangerous_os "$@"; then
    die "Blocked mutating command (readonly tool)."
  fi
  log "INFO" "OS cmd=openstack $*"
  run_openstack "$@"
}

# ---------- list subcommands ----------

# projects: list projects [name|id] <value...>  OR list projects <tokens...>
parse_mode_query_projects(){
  local mode="tokens"
  if [[ $# -ge 1 ]]; then
    case "$1" in
      name|id) mode="$1"; shift ;;
    esac
  fi
  printf '%s\n%s\n' "$mode" "${*:-}"
}

# vms: list vms [name|id|vol] <value...>  OR list vms <tokens...>
# 'vol' == volume id (uuid or partial). Keep 'volid' as alias.
parse_mode_query_vms(){
  local mode="tokens"
  if [[ $# -ge 1 ]]; then
    case "$1" in
      name|id|vol) mode="$1"; shift ;;
      volid|volume-id) mode="vol"; shift ;;
    esac
  fi
  printf '%s\n%s\n' "$mode" "${*:-}"
}

cmd_list_projects(){
  need python3
  need mktemp

  local profile cfg mode query
  profile="$(get_active)"
  cfg="$(cfg_path "$profile")"
  [[ -r "$cfg" ]] || die "Profile not readable: $cfg (add your user to group '$GROUP')"
  require_session_password

  { read -r mode; read -r query; } < <(parse_mode_query_projects "$@")

  local cfg_json_file proj_json_file
  cfg_json_file="$(mktemp)"
  proj_json_file="$(mktemp)"
  trap 'rm -f "'"$cfg_json_file"'" "'"$proj_json_file"'" 2>/dev/null || true' RETURN

  run_openstack configuration show -f json >"$cfg_json_file" 2>/dev/null || printf '{}' >"$cfg_json_file"
  run_openstack project list -f json >"$proj_json_file"

  OS_CLIENT_CONFIG_FILE="$cfg" \
  OS_CLOUD="$DEFAULT_CLOUD" \
  OS_PASSWORD="${!SESSION_PASS_ENV}" \
  python3 - "$profile" "$DEFAULT_CLOUD" "$cfg" "$cfg_json_file" "$proj_json_file" "$mode" "$query" <<'PY'
import sys, os, json, re, shutil, datetime
from pathlib import Path

profile, cloud = sys.argv[1], sys.argv[2]
clouds_yaml_path = sys.argv[3]
cfg_path, proj_path = sys.argv[4], sys.argv[5]
mode = (sys.argv[6] or "tokens").strip().lower()
query_raw = (sys.argv[7] or "").strip()
q = query_raw.lower()
tokens = [t for t in q.split() if t]

term_cols = shutil.get_terminal_size((120, 20)).columns
HEX = re.compile(r"[0-9a-f]", re.I)

def norm_id(s: str) -> str:
  s = (s or "").strip().lower()
  s = s.replace("-", "")
  s = "".join(ch for ch in s if HEX.match(ch))
  return s

def load_json(path, default):
  try:
    with open(path, "r", encoding="utf-8") as f:
      return json.load(f)
  except Exception:
    return default

def parse_clouds_yaml_auth_url(path, want_cloud):
  in_clouds = in_target = in_auth = False
  target_indent = auth_indent = None
  auth_url = region = domain = ""
  try:
    for raw in Path(path).read_text(encoding="utf-8").splitlines():
      line = raw.split("#",1)[0].rstrip("\n")
      if not line.strip():
        continue
      indent = len(line) - len(line.lstrip(" "))
      s = line.strip()

      if s == "clouds:":
        in_clouds = True
        in_target = in_auth = False
        target_indent = auth_indent = None
        continue

      if in_clouds and indent == 2 and s.endswith(":"):
        key = s[:-1].strip()
        in_target = (key == want_cloud)
        target_indent = 2 if in_target else None
        in_auth = False
        auth_indent = None
        continue

      if in_target and target_indent is not None:
        if indent <= target_indent:
          in_target = in_auth = False
          continue

        if s == "auth:" and indent == target_indent + 2:
          in_auth = True
          auth_indent = indent
          continue

        if in_auth and auth_indent is not None:
          if indent <= auth_indent:
            in_auth = False
          else:
            if s.startswith("auth_url:") and not auth_url:
              auth_url = s.split(":",1)[1].strip().strip('"').strip("'")
            if s.startswith("user_domain_name:") and not domain:
              domain = s.split(":",1)[1].strip().strip('"').strip("'")

        if s.startswith("region_name:") and indent == target_indent + 2 and not region:
          region = s.split(":",1)[1].strip().strip('"').strip("'")
        if s.startswith("user_domain_name:") and indent == target_indent + 2 and not domain:
          domain = s.split(":",1)[1].strip().strip('"').strip("'")
  except Exception:
    pass
  return auth_url, region, domain

cfg = load_json(cfg_path, {})
projects_raw = load_json(proj_path, [])

region = cfg.get("region_name") or cfg.get("region") or ""
domain = cfg.get("user_domain_name") or cfg.get("project_domain_name") or cfg.get("domain_name") or ""
auth_url = cfg.get("auth_url") or ""

y_auth_url, y_region, y_domain = parse_clouds_yaml_auth_url(clouds_yaml_path, cloud)
auth_url = auth_url or y_auth_url
region = region or y_region
domain = domain or y_domain

endpoint = ""
m = re.match(r"^(https?://[^/]+)", auth_url or "")
if m:
  endpoint = re.sub(r":5000$","",m.group(1))

def status_text(p):
  v = p.get("Enabled", p.get("enabled", None))
  if v in (True, "True", "true", "enabled", "Enabled", "YES", "Yes", "yes", 1, "1"):
    return "Enabled"
  if v in (False, "False", "false", "disabled", "Disabled", "NO", "No", "no", 0, "0"):
    return "Disabled"
  return ""

# Dedup by ProjectID
proj_by_id = {}
for p in projects_raw:
  pid = str(p.get("ID") or p.get("id") or "").strip()
  if pid and pid not in proj_by_id:
    proj_by_id[pid] = p

q_norm = norm_id(q)

headers = ["Region","Domain","Endpoint","ProjectName","ProjectID","Status"]
rows = []

for pid, p in proj_by_id.items():
  pname = str(p.get("Name") or p.get("name") or "").strip()
  st = status_text(p)

  if mode == "id":
    if not q_norm:
      continue
    pid_norm = norm_id(pid)
    if len(q_norm) < len(pid_norm):
      if q_norm not in pid_norm:
        continue
    else:
      if q_norm != pid_norm:
        continue

  elif mode == "name":
    if not q:
      continue
    if q not in pname.lower():
      continue

  else:  # tokens
    if tokens:
      hay = f"{region} {domain} {endpoint} {pname} {pid} {st}".lower()
      if not all(t in hay for t in tokens):
        continue

  rows.append([region, domain, endpoint, pname, pid, st])

rows.sort(key=lambda r: (r[3].lower(), r[4]))

w = [len(h) for h in headers]
for r in rows:
  for i, c in enumerate(r):
    w[i] = max(w[i], len(str(c)))

sep = "  "
def fmt(r):
  return sep.join(str(r[i]).ljust(w[i]) for i in range(len(w)))

title_raw = f"URIOSP LIST PROJECTS | profile={profile} | cloud={cloud} | region={region} | endpoint={endpoint} | time={datetime.datetime.now().isoformat(timespec='seconds')}"

is_tty = sys.stdout.isatty()
use_color = is_tty and os.environ.get("NO_COLOR") is None and os.environ.get("URIOSP_COLOR", "1") != "0"

bg = os.environ.get("URIOSP_TITLE_BG", "44")
fg = os.environ.get("URIOSP_TITLE_FG", "97")

if is_tty:
  line = f" {title_raw} "
  pad = max(0, term_cols - len(line))
  line = line + (" " * pad)
else:
  line = title_raw

print(f"\033[1;{fg};{bg}m{line}\033[0m" if use_color else line)

hdr = fmt(headers)
line_w = term_cols
print(hdr)
print("-" * line_w)

for r in rows:
  print(fmt(r))
PY
}

cmd_list_vms(){
  need python3
  need mktemp

  local profile cfg mode query
  profile="$(get_active)"
  cfg="$(cfg_path "$profile")"
  [[ -r "$cfg" ]] || die "Profile not readable: $cfg (add your user to group '$GROUP')"
  require_session_password

  { read -r mode; read -r query; } < <(parse_mode_query_vms "$@")

  local proj_json_file net_json_file srv_json_file vol_json_file
  proj_json_file="$(mktemp)"
  net_json_file="$(mktemp)"
  srv_json_file="$(mktemp)"
  vol_json_file="$(mktemp)"
  trap 'rm -f "'"$proj_json_file"'" "'"$net_json_file"'" "'"$srv_json_file"'" "'"$vol_json_file"'" 2>/dev/null || true' RETURN

  run_openstack project list -f json >"$proj_json_file"
  run_openstack network list -f json >"$net_json_file" 2>/dev/null || printf '[]' >"$net_json_file"

  # Force columns to keep project fields when possible
  if run_openstack server list --all-projects --long -f json \
      -c ID -c Name -c Status -c Networks -c "Project ID" -c Project -c "Power State" \
      >"$srv_json_file" 2>/dev/null; then
    :
  elif run_openstack server list --all-projects --long -f json \
      -c ID -c Name -c Status -c Networks -c "Project ID" -c Project \
      >"$srv_json_file" 2>/dev/null; then
    :
  elif run_openstack server list --all-projects --long -f json \
      -c ID -c Name -c Status -c Networks -c "Tenant ID" -c Tenant -c "Power State" \
      >"$srv_json_file" 2>/dev/null; then
    :
  elif run_openstack server list --all-projects --long -f json \
      -c ID -c Name -c Status -c Networks -c "Tenant ID" -c Tenant \
      >"$srv_json_file" 2>/dev/null; then
    :
  elif run_openstack server list --all-projects --long -f json >"$srv_json_file" 2>/dev/null; then
    :
  else
    run_openstack server list --all-projects -f json >"$srv_json_file"
  fi

  # Volume bulk list (best effort; can be heavy on prod)
  if run_openstack volume list --all-projects --long -f json >"$vol_json_file" 2>/dev/null; then
    :
  elif run_openstack volume list --all-projects -f json >"$vol_json_file" 2>/dev/null; then
    :
  elif run_openstack volume list --long -f json >"$vol_json_file" 2>/dev/null; then
    :
  else
    printf '[]' >"$vol_json_file"
  fi

  OS_CLIENT_CONFIG_FILE="$cfg" \
  OS_CLOUD="$DEFAULT_CLOUD" \
  OS_PASSWORD="${!SESSION_PASS_ENV}" \
  python3 - "$profile" "$DEFAULT_CLOUD" "$proj_json_file" "$net_json_file" "$srv_json_file" "$vol_json_file" "$mode" "$query" <<'PY'
import sys, os, json, re, ast, shutil, datetime

profile, cloud = sys.argv[1], sys.argv[2]
proj_path, net_path, srv_path, vol_path = sys.argv[3], sys.argv[4], sys.argv[5], sys.argv[6]
mode = (sys.argv[7] or "tokens").strip().lower()
query_raw = (sys.argv[8] or "").strip()
q = query_raw.lower()
tokens = [t for t in q.split() if t]

term_cols = shutil.get_terminal_size((120, 20)).columns

UUID36 = r"[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"
UUID32 = r"[0-9a-f]{32}"
ANY_UUID = re.compile(rf"(?:{UUID36}|{UUID32})", re.I)

IPv4  = re.compile(r"\b\d{1,3}(?:\.\d{1,3}){3}\b")
IPv6  = re.compile(r"\b[0-9a-f]{0,4}:[0-9a-f:]{2,}\b", re.I)

HEX = re.compile(r"[0-9a-f]", re.I)

def norm_id(s: str) -> str:
  s = (s or "").strip().lower().replace("-", "")
  s = "".join(ch for ch in s if HEX.match(ch))
  return s

q_norm = norm_id(q)

def load_json(path, default):
  try:
    with open(path, "r", encoding="utf-8") as f:
      return json.load(f)
  except Exception:
    return default

def get_ci(row, names, default=""):
  if not isinstance(row, dict):
    return default
  lower = {str(k).lower(): k for k in row.keys()}
  for n in names:
    k = lower.get(str(n).lower())
    if k is not None:
      return row.get(k)
  return default

projects = load_json(proj_path, [])
nets = load_json(net_path, [])
servers_raw = load_json(srv_path, [])
vols = load_json(vol_path, [])

# Dedup servers by ID (normalized)
seen_sid=set()
servers=[]
for r in servers_raw:
  sid = str(get_ci(r, ["ID","id"], "") or "").strip()
  sid_n = norm_id(sid)
  if sid_n and sid_n not in seen_sid:
    seen_sid.add(sid_n)
    servers.append(r)

proj_name_by_id = {}
proj_id_by_name = {}
for p in projects:
  pid = str(get_ci(p, ["ID","id"], "") or "").strip()
  if not pid:
    continue
  name = str(get_ci(p, ["Name","name"], "") or "").strip()
  proj_name_by_id[pid] = name
  if name and name not in proj_id_by_name:
    proj_id_by_name[name] = pid

net_id_by_name = {}
for n in nets:
  nn = str(get_ci(n, ["Name","name"], "") or "").strip()
  nid = str(get_ci(n, ["ID","id"], "") or "").strip()
  if nn and nid:
    net_id_by_name[nn] = nid

def dedup(seq):
  out=[]
  for x in seq:
    if x and x not in out:
      out.append(x)
  return out

def power_state_str(val):
  m = {0:"NOSTATE",1:"RUNNING",3:"PAUSED",4:"SHUTDOWN",6:"CRASHED",7:"SUSPENDED"}
  try:
    if val is None: return ""
    if isinstance(val, str) and val.strip().isdigit():
      return m.get(int(val.strip()), val.strip())
    if isinstance(val, int):
      return m.get(val, str(val))
    return str(val)
  except Exception:
    return str(val) if val is not None else ""

def parse_networks_pairs(val):
  pairs=[]
  if val is None:
    return pairs

  if isinstance(val, dict):
    for net, v in val.items():
      net = str(net) if net is not None else ""
      if isinstance(v, list):
        for it in v:
          if isinstance(it, str):
            ip = it.strip()
            if ip and (IPv4.fullmatch(ip) or IPv6.fullmatch(ip)):
              pairs.append((ip, net))
          elif isinstance(it, dict) and it.get("addr"):
            ip = str(it.get("addr")).strip()
            if ip and (IPv4.fullmatch(ip) or IPv6.fullmatch(ip)):
              pairs.append((ip, net))
      elif isinstance(v, str):
        ip = v.strip()
        if ip and (IPv4.fullmatch(ip) or IPv6.fullmatch(ip)):
          pairs.append((ip, net))
    out=[]; seen=set()
    for ip, nn in pairs:
      if (ip, nn) in seen: continue
      seen.add((ip, nn))
      out.append((ip, nn))
    return out

  s=str(val).strip()
  if not s:
    return []

  if s.startswith("{") and s.endswith("}"):
    try:
      obj = ast.literal_eval(s)
      if isinstance(obj, dict):
        return parse_networks_pairs(obj)
    except Exception:
      pass

  tokens2 = [t.strip() for t in s.replace(";", ",").split(",") if t.strip()]
  cur = ""
  for t in tokens2:
    if "=" in t:
      net, rest = t.split("=", 1)
      cur = net.strip()
      rest = rest.strip()
      for ip in re.split(r"\s+", rest):
        ip = ip.strip()
        if ip and (IPv4.fullmatch(ip) or IPv6.fullmatch(ip)):
          pairs.append((ip, cur))
    else:
      ip = t.strip()
      if ip and (IPv4.fullmatch(ip) or IPv6.fullmatch(ip)):
        pairs.append((ip, cur))

  if not pairs:
    for ip in IPv4.findall(s):
      pairs.append((ip, ""))
    for ip in IPv6.findall(s):
      pairs.append((ip, ""))

  out=[]; seen=set()
  for ip, nn in pairs:
    if (ip, nn) in seen: continue
    seen.add((ip, nn))
    out.append((ip, nn))
  return out

def volume_meta(vrow):
  vid = str(get_ci(vrow, ["ID","id"], "") or "").strip()
  if not vid:
    return None
  name = str(get_ci(vrow, ["Name","name"], "") or "").strip()
  size = get_ci(vrow, ["Size","size"], None)

  size_s = ""
  try:
    if size is not None and str(size).strip() != "":
      size_s = f"{int(size)}gb"
  except Exception:
    size_s = ""

  # keep readable label
  if size_s:
    label = f"{size_s}({vid})" if not name else f"{name}:{size_s}({vid})"
  else:
    label = f"{vid}" if not name else f"{name}({vid})"

  return {"id": vid, "id_norm": norm_id(vid), "label": label}

def attached_server_ids(vrow):
  keys = ["Attachments","attachments","Attached to","Attached To","attached_to","AttachedTo","attachment"]
  raw = None
  for k in keys:
    v = get_ci(vrow, [k], None)
    if v:
      raw = v
      break

  ids=[]
  if isinstance(raw, list):
    for it in raw:
      if isinstance(it, dict):
        sid = it.get("server_id") or it.get("serverId") or it.get("server") or ""
        if sid:
          ids.append(norm_id(str(sid)))
  elif isinstance(raw, dict):
    sid = raw.get("server_id") or raw.get("server") or ""
    if sid:
      ids.append(norm_id(str(sid)))
  elif isinstance(raw, str):
    for m in ANY_UUID.findall(raw):
      ids.append(norm_id(m))

  return dedup([i for i in ids if i])

# vols_by_server: key=normalized server id, value=list[meta]
vols_by_server = {}
for v in vols:
  meta = volume_meta(v)
  if not meta:
    continue
  for sid_norm in attached_server_ids(v):
    vols_by_server.setdefault(sid_norm, [])
    # dedup by volume id_norm
    if not any(x["id_norm"] == meta["id_norm"] for x in vols_by_server[sid_norm]):
      vols_by_server[sid_norm].append(meta)

headers = ["ProjectName","ProjectID","InstanceName","InstanceID","Volume","IP","NetworkName","NetworkID","Status","PowerState"]
blocks=[]

for row in servers:
  sid = str(get_ci(row, ["ID","id"], "") or "").strip()
  sid_norm = norm_id(sid)
  if not sid_norm:
    continue

  sname = str(get_ci(row, ["Name","name"], "") or "").strip()
  status = str(get_ci(row, ["Status","status"], "") or "").strip()

  pid = get_ci(row, ["Project ID","Project_ID","project_id","Tenant ID","tenant_id","tenant"], "") or ""
  pid = str(pid).strip()

  if not pid:
    p_name_only = str(get_ci(row, ["Project","project","Tenant","tenant"], "") or "").strip()
    if p_name_only:
      pid = proj_id_by_name.get(p_name_only, "")

  pname = proj_name_by_id.get(pid, "") if pid else ""

  pstate = get_ci(row, ["Power State","power_state","OS-EXT-STS:power_state"], "") or ""
  pstate = power_state_str(pstate)

  nets_val = get_ci(row, ["Networks","networks"], "") or ""
  ip_pairs = parse_networks_pairs(nets_val)

  vol_metas = vols_by_server.get(sid_norm, [])
  vol_labels = [m["label"] for m in vol_metas]

  max_len = max(len(vol_labels), len(ip_pairs), 1)

  lines=[]
  for i in range(max_len):
    vol = vol_labels[i] if i < len(vol_labels) else ""
    if i < len(ip_pairs):
      ip, net_name = ip_pairs[i]
      net_id = net_id_by_name.get(net_name, "") if net_name else ""
    else:
      ip, net_name, net_id = "", "", ""

    if i == 0:
      lines.append([pname, pid, sname, sid, vol, ip, net_name, net_id, status, pstate])
    else:
      lines.append(["","","","", vol, ip, net_name, net_id, "", ""])

  # Mode filter
  if mode == "id":
    if not q_norm:
      continue
    # match normalized id (supports 32/36, with/without '-')
    if len(q_norm) < len(sid_norm):
      if q_norm not in sid_norm:
        continue
    else:
      if q_norm != sid_norm:
        continue

  elif mode == "name":
    if not q:
      continue
    if q not in sname.lower():
      continue

  elif mode == "vol":
    if not q_norm:
      continue
    any_match = False
    for m in vol_metas:
      vid_n = m["id_norm"]
      if len(q_norm) < len(vid_n):
        if q_norm in vid_n:
          any_match = True
          break
      else:
        if q_norm == vid_n:
          any_match = True
          break
    if not any_match:
      continue

  else:  # tokens
    if tokens:
      hay = " ".join(" ".join(str(x) for x in ln if x) for ln in lines).lower()
      if not all(t in hay for t in tokens):
        continue

  blocks.append(((pname.lower(), sname.lower(), sid), lines))

blocks.sort(key=lambda x: x[0])

w=[len(h) for h in headers]
for _, lines in blocks:
  for r in lines:
    for i, c in enumerate(r):
      w[i] = max(w[i], len(str(c)))

sep="  "
def fmt(r):
  return sep.join(str(r[i]).ljust(w[i]) for i in range(len(w)))

title_raw = f"URIOSP LIST VMS | profile={profile} | cloud={cloud} | time={datetime.datetime.now().isoformat(timespec='seconds')}"

is_tty = sys.stdout.isatty()
use_color = is_tty and os.environ.get("NO_COLOR") is None and os.environ.get("URIOSP_COLOR", "1") != "0"

# default: blue bg (44), bright white fg (97)
bg = os.environ.get("URIOSP_TITLE_BG", "44")
fg = os.environ.get("URIOSP_TITLE_FG", "97")

# pad to terminal width only when TTY
if is_tty:
  line = f" {title_raw} "
  pad = max(0, term_cols - len(line))
  line = line + (" " * pad)
else:
  line = title_raw

print(f"\033[1;{fg};{bg}m{line}\033[0m" if use_color else line)

hdr = fmt(headers)
line_w = term_cols
print(hdr)
sep_line = "-" * line_w
print(sep_line)

for _, lines in blocks:
  for r in lines:
    print(fmt(r))
  print(sep_line)
PY
}

cmd_list(){
  local what="${1:-profiles}"
  shift || true

  case "$what" in
    ""|profiles|profile)
      cmd_list_profiles
      ;;
    projects|project)
      log "INFO" "LIST projects"
      cmd_list_projects "$@"
      ;;
    vms|vm|servers|server)
      log "INFO" "LIST vms"
      cmd_list_vms "$@"
      ;;
    -h|--help|help)
      cat <<EOF
Usage:
  $APP list
  $APP list profiles

  $APP list projects [keyword...]
  $APP list projects name <project_name_substring>
  $APP list projects id <project_id_or_part>

  $APP list vms [keyword...]
  $APP list vms name <vm_name_substring>
  $APP list vms id <instance_id_or_part>
  $APP list vms vol <volume_id_or_part>     # vol == volume id

Session auth:
  eval "\$($APP auth)"

Notes:
  - Default search is token-based AND: "my vm 10.10" matches blocks containing all tokens.
  - Readonly: '$APP os' blocks mutating verbs.
EOF
      ;;
    *)
      die "Unknown list target: $what (use: profiles|projects|vms)"
      ;;
  esac
}

# Backward-compat alias: inventory -> list
cmd_inventory(){
  cmd_list "$@"
}

cmd_logs(){
  [[ -r "$LOGFILE" ]] || { echo "(no logs yet or no permission)"; exit 0; }
  tail -n 200 "$LOGFILE"
}

usage(){
  cat <<EOF
$APP - OpenStack ops CLI (default cloud: $DEFAULT_CLOUD)

Session auth (no password stored in YAML):
  eval "\$($APP auth)"

Commands:
  sudo $APP config <clouds.yaml>
  $APP use <profile>
  $APP list [profiles|projects|vms] ...
  $APP os <openstack ...>                 (readonly-guarded)
  $APP logs

Legacy alias:
  $APP inventory ...                      (same as: $APP list ...)
EOF
}

case "${1:-}" in
  auth) shift; cmd_auth ;;
  config) shift; cmd_config "$@" ;;
  use) shift; cmd_use "$@" ;;
  list) shift; cmd_list "$@" ;;
  inventory|inv) shift; cmd_inventory "$@" ;;
  os) shift; cmd_os "$@" ;;
  logs) shift; cmd_logs ;;
  -h|--help|help|"") usage ;;
  *) die "Unknown command: $1 (use --help)" ;;
esac
SH

sudo chmod +x /usr/local/bin/uriosp



# Idempotent permission bootstrap
sudo groupadd -f uriosp
sudo mkdir -p /etc/uriosp/profile /var/log/uriosp-logs
sudo touch /etc/uriosp/active /var/log/uriosp-logs/uriosp.log
sudo chown -R root:uriosp /etc/uriosp /var/log/uriosp-logs
sudo chmod 0750 /etc/uriosp /etc/uriosp/profile
sudo chmod 0640 /etc/uriosp/active
sudo chmod 0770 /var/log/uriosp-logs
sudo chmod 0660 /var/log/uriosp-logs/uriosp.log
